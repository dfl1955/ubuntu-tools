#!/bin/bash

# This has nt yet been tested.

#=====================================================================

# This program compares the installed packages with a manifest and 
# produces a list of the newly installed packages i.e. those that I
# have installed.

# It declares functions, analyses the switches. checks that it has
# the privileges and resources it requires and then performs its work

#=====================================================================
#
# functions

lfiles ()
{
# repeated in fn wos
for i in $(ls /etc/*release)
do
	if [ -f ${i} ];then
		cat $i
	fi
done
}

mkwd()
{
	# this sudo needs to be re-factored
	sudo mkdir -p  $1
	chmod -R 777 ${ROOTDIR}
}

# difverbose() ; # display if verbose

# set's the results directory

ROOTDIR=/opt/local
WORKDIR=${ROOTDIR}/var/whatsnew

case $( [[ -d ${WORKDIR} ]]) in
true)	resultsdir=true; ;;
false)	resultsdir=false; ;;
esac

oninstall=${WORKDIR}/oninstall.1word
foundpkgs=${WORKDIR}/found.1word
afterthought=${WORKDIR}/afterthought.lis

case `whoami` in
root) 	superuser=true; echo I am root;  ;;
*)	superuser=false; echo I am not root; ;;
esac

wos()
{
rfiles=$( for rfile in $( ls /etc/*release )
do
	if [ -f $rfile ];then
		echo $rfile
	fi
done )
cat $rfiles | grep ^PRETTY | cut -f2 -d'=' | tr -d '"' | cut -f1 -d" " 2>/dev/null
#cat /etc/*release | grep ^PRETTY | cut -f2 -d'=' | tr -d '"' | cut -f1 -d" " 2>/dev/null
}
 
WOS=`wos` 

# this program requires curl, I could use apt-cache policy to make the check,
# but I chose to use 'which'.

if [ $( which curl | wc -l ) -eq 0 ];then
	echo curl is not installed, please install it
	exit 3
fi

# also needs dpkg & cut & awk

#=====================================================================

pname=$0
usage="$0  -ivshc "
verbose=false

# I need a install, verbose, clean, help and show switch

while getopts ivshc opt
do
case $opt in
-i|i)	# this is the install leg
	# needs to be root
	echo $pname $VNAME $VER ... in install results directory
	if [ ! -d ${WORKDIR} ];then
		echo There is no ${WORKDIR} on this system, I\'ll make you one.
		mkwd ${WORKDIR}
	else
		echo ${WORKDIR} already exists on this system
	fi
	exit
	;;
-h|h) 	echo $usage; exit
	;;
-v|v) 	# this is the verbose leg
	verbose=true
	echo $pname $VNAME $VER ... in verbose mode
	WOS=`wos` ; echo OS is $WOS
	;;
-c|c)	# this is the clean files leg
	cleanresults=true
	rm ${remotemanifest} ${oninstall} ${foundpkgs}  ${afterthought}
	exit
	;;
-s|s)	# this is the show leg
	echo $pname $VNAME $VER ... show results
	;;
*)	echo $usage
	exit 1
	;;
esac
done

# needs some code to test cross validation of switches 
# i.e. not s && i

#=====================================================================
#
# This code assume ubuntu or more accuralty is known not to work with
# on the raspberry pi. It is used to derive the manifest file location

# VNAME=$( cat /etc/*release | grep CODENAME | cut -f2 -d'=' | uniq )
VNAME=$( lfiles | grep CODENAME | cut -f2 -d'=' | uniq )
# this now includes a directory on elementary
#VER=$( cat /etc/*release | grep RELEASE | cut -f2 -d'=' | uniq )
VER=$( lfiles | grep RELEASE | cut -f2 -d'=' | uniq )

#=====================================================================

# a couple more tests, are they needed

VERROR=0

if [ ! -d ${WORKDIR} ];then
	echo There is no ${WORKDIR} on this system, I\'ll make you one.
	# we could make it ourself
	mkwd ${WORKDIR}
	VERROR=1
fi

if [ ${VERROR} -eq 1 ];then
	exit ${VERROR}
fi
 
#=====================================================================
# what am i, these lines will vary depending on what it runs on, they work
# for ubuntu & elementary


case `wos` in 
elementary) : 
	if [[ ${verbose} == true ]];then
		# this isn't working properly
		echo elementary processing path
	fi
	VNAME=$( lfiles | grep CODENAME | cut -f2 -d'=' | uniq )
	VER=$( lfiles | grep RELEASE | cut -f2 -d'=' | uniq )
#	this doesn't work, we need the Elementary Manifest or the Equiv. Ubuntu manifest
	remotemanifestname=ubuntu-${VER}-desktop-amd64.manifest
	fullremotename=http://releases.ubuntu.com/${VNAME}/${remotemanifestname}
	remotemanifest=${WORKDIR}/ubuntu-${VER}-desktop-amd64.manifest
	echo this path is not yet supported
	exit 10
	;;
ubuntu) :
	[verbose] && echo ubuntu processing path
	VNAME=$( lfiles | grep CODENAME | cut -f2 -d'=' | uniq )
	VER=$( lfiles | grep RELEASE | cut -f2 -d'=' | uniq )
	remotemanifestname=ubuntu-${VER}-desktop-amd64.manifest
	fullremotename=http://releases.ubuntu.com/${VNAME}/${remotemanifestname}
	remotemanifest=${WORKDIR}/ubuntu-${VER}-desktop-amd64.manifest
	;;
raspbian|Raspbian) :
	echo No code available for the Rasberry yet; exit 2
	;;
*)	VNAME=$( lfiles | grep CODENAME | cut -f2 -d'=' | uniq )
	VER=$( lfiles | grep RELEASE | cut -f2 -d'=' | uniq )
	remotemanifestname=ubuntu-${VER}-desktop-amd64.manifest
	fullremotename=http://releases.ubuntu.com/${VNAME}/${remotemanifestname}
	remotemanifest=${WORKDIR}/ubuntu-${VER}-desktop-amd64.manifest
	;;
esac

exit	
#=====================================================================
# main process path

curl -o ${remotemanifest} -O $fullremotename 2>/dev/null
# if [ $? != 0 ];then etc
cut -f1 ${remotemanifest} | sort > ${oninstall}

dpkg --get-selections | awk '$2 ~ /^(install|hold)/ { print $1 }' | sort > ${foundpkgs} 

comm -23 ${foundpkgs} ${oninstall} > ${afterthought}

# a verbose switch to display the after thoughts  file

lines=$( wc -l ${afterthought} | awk '{ print $1 }')
echo There are $lines  lines in the "afterthoughts" file

if [ $verbose == true ];then
	cat ${afterthought}
else
	echo The afterthoughts file is called ${afterthought}
fi

# cat /etc/*release | grep CODENAME | cut -f2 -d'=' | uniq 
